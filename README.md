### Постановка.
> Требования к кандидату по тестовому заданию:
– Умение реализовывать проекты построенные на архитектуре SOA
– Показать хорошие знания одного из фреймворков: Laravel / Yii / Symfony или Phalcon
>
> Тестовое задание:
Создайте 2 разделенных проекта с названиями landing и activity.<br> 
> landing – это основной сайт<br>
> activity – система учета визитов пользователя
> 
> При переходе на ЛЮБЫЕ страницы landing вы передаете информацию в проект activity по протоколу json-rpc версии 2.0. Информация должна содержать URL и Дату.
На странице (landing): /admin/activity выведите историю активности с пагинацией сгруппированную по URL. Поля таблицы: URL, Количество визитов, Последнее посещение. Эту информацию вы запрашиваете в проекте activity (json-rpc запрос).
> 
> Все запросы landing должен делать через серверную часть (не использовать Ajax). Проект activity должен быть закрыт от прямого доступа.

### Как запустить
1. Выполнить `composer install`
2. Запустить `docker-compose up --build`
3. Открыть <http://localhost:8080> (при необходимости изменить внешний порт в `docker-compose.yml:7`)

### Что тут происходит.
1. Для экономии времени оба ресурса сделаны в одном проекте (чтобы не дублировать сущности, напрашивающиеся в бандл, gitmodules, etc). В докере запускаются два инстанса: `fpm` (`landing`) для работы в браузере и `cli` (`activity`) для обработки очередей.
2. На стартовой странице при клике на `Сгенерировать адреса` генерируется 20 случайных ссылок (для упрощения кладутся в localStorage браузера).
3. При переходе на страницу сенерированной ссылки `landing` ставит в очередь (тут использовал redis queue) сообщение, которое затем подхватывает `activity`. 
4. Непосредственно перед передачей в очередь сообщение приводится к формату протокола [JSON-RPC 2.0](https://www.jsonrpc.org/specification). Делал максимально упрощённо, без обработки ошибок и т.п..
5. `activity`, в свою очередь, распаковывает сообщение и записывает содержимое в redis (тоже для простоты, чтоб не поднимать рядом рсубд). Если запись уже была сделана, инкрементиуется счётчик заходов и обновляется время последнего доступа. 

Собственно всё предельно просто. Ни `activity`, ни redis напрямую вовне не смотрят, так просто до них не достучаться.


### Что не сделано
1. Валидации
2. Обработки ошибок
3. В `ActivityService`, по-хорошему, нужно использовать не `RedisClient`, а написать отдельный сервис-провайдер, что-бы была возможность менять клиентов не трогая бизнес. 
4. В постановке небыло, но можно было бы результаты в рсубд писать. Хотя тут это не принципиально.
5. Конечно же тесты

Писал по-быстрому, на всё про всё потратил пару часов (некоторые моменты пришлось освежить в памяти).  
